---
layout: default
title: "Lab 2: Typeclasses"
---

<h1>Lab #2: Typeclasses</h1>

<p>This lab is intended to introduce you to the concept of typeclasses, how they can be used to make generic types and generic functions, and to learn about the design and usefulness of interfaces combined with parametric polymorphism.

<p>If at any point you find something confusing, feel free to ask questions about it.</p>

<h2>Generic Parameters</h2>

<p>In the last lab, we saw some functions that took a generic parameter, like so:</p>

<pre><code class="Haskell">generic :: [a] -&gt; Int
generic l = length l
</code></pre>

<p>But we didn’t talk very much about it. This generic function signature means that <code>generic</code> can take in a list of <em>any single type</em>. The function is <em>generic</em> over the type of the values in the list.</p>

<p>So any of the following uses of the function will work:</p>

<pre><code class="Haskell">generic [1, 2, 3]
generic ['a', 'b', 'c']
generic [1.0, 2.0, 3.0]
</code></pre>

<p>Even cooler, there’s no overhead (no performance cost at runtime) for this generic function! When the program is compiled, the compiler looks at all the “call sites” (places in the code that call <code>generic</code>) and sees the “concrete types” (<code>Int</code>, <code>Char</code>, <code>Float</code>) being passed, and it generates separate copies of <code>generic</code> for each concrete type. This process is called “monomorphization.”</p>

<p>So the above code gets turned into something like this:</p>

<pre><code class="Haskell">genericInt :: [Int] -&gt; Int
genericInt l = length l

genericChar :: [Char] -&gt; Int
genericChar l = length l

genericFloat :: [Float] -&gt; Int
genericFloat l = length l

genericInt [1, 2, 3]
genericChar ['a', 'b', 'c']
genericFloat [1.0, 2.0, 3.0]
</code></pre>

<p>This is monomorphization, and it’s one of the things that makes Haskell’s implementation of generics parameters so cool!</p>

<p>Now, when I say “generics,” I actually mean “parametric polymorphism.” Parametric polymorphism means that the function is “polymorphic” (many forms) with respect to its parameters. So you can pass parameters of different types, and the function handles them correctly. Parametric polymorphism is the technical term, but you’ll often see this called “generics” in the real world, so it’s good to know both.</p>

<h2>Interfaces</h2>

<p>Now, wouldn’t it be nice if we could put some constraints on the generic parameters to our functions? What if we want to say “this function takes any type that implements addition”? This would be a really powerful feature. In essence, we want to be able to constrain the generic parameters by requiring that they implement a particular interface. In Haskell, we can do that! With something called “typeclasses.”</p>

<p>A typeclass in Haskell looks like this:</p>

<pre><code class="Haskell">class Add t where
    plus :: t -&gt; t -&gt; t
</code></pre>

<p>This defines a typeclass called <code>Add</code>. <code>Add</code> is an interface that types can implement, with only a single function it requires, called <code>plus</code>. Here’s an example implementation:</p>

<pre><code class="Haskell">data Intish = Intish Integer

instance Add Intish where
    plus :: Intish -&gt; Intish -&gt; Intish
    plus (Intish i) (Intish j) = Intish (i + j)
</code></pre>

<p>This defines a type <code>Intish</code> that is just a wrapper around an <code>Integer</code>, and implements <code>Add</code> for it by just adding the internal integers together.</p>

<p>So now, if we have a function where we want the input type to implement <code>Add</code>, we write it like so:</p>

<pre><code class="Haskell">blah :: (Add a) =&gt; a -&gt; a -&gt; a
Blah x y = plus x y
</code></pre>

<p>This signature says that blah takes in two parameters of the same type, which implements <code>Add</code>, and returns a result of that type. Inside the function body, it calls <code>plus</code>, which is provided by the <code>Add</code> interface.</p>

<p>And that’s how typeclasses work! Pretty cool right?</p>

<p><strong>Write your own typeclass, write a type that implements it, and write a function that’s generic over it. Make sure the code compiles, and save it in a .hs file for submission at the end of the lab.</strong></p>

<h2>Important Haskell Typeclasses</h2>

<p>Typeclasses are a major mechanism within Haskell (in fact, they’re probably Haskell’s core feature, outside of laziness and purity). As such, Haskell comes with a collection of built-in typeclasses you can and should use with your own types. They are as follows:</p>

<h3><code>Eq</code></h3>

<p>The <code>Eq</code> typeclass is used for types that can be compared for equality. It looks like this:</p>

<pre><code class="Haskell">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
</code></pre>

<p>The first function is for comparing whether two instances of the implementing type are equal. The second function is for comparing whether they’re not equal. You only need to implement one, as the other is automatically derived in terms of the one you implement.</p>

<h3><code>Ord</code></h3>

<p>The <code>Ord</code> typeclass is used for types that can be compared for an ordering. It looks like this:</p>

<pre><code class="Haskell">data Ordering = LT | GT | EQ

class Eq a =&gt; Ord a where
    compare :: a -&gt; a -&gt; Ordering
    &lt; :: a -&gt; a -&gt; Bool
    &lt;= :: a -&gt; a -&gt; Bool
    &gt; :: a -&gt; a -&gt; Bool
    &gt;= :: a -&gt; a -&gt; Bool
    max :: a -&gt; a -&gt; a
    min :: a -&gt; a -&gt; a
</code></pre>

<p>The <code>Eq a =&gt; Ord a</code> means that a type has to implement <code>Eq</code> to implement <code>Ord</code>. And all the functions are what you’d expect them to be.</p>

<h3><code>Show</code></h3>

<p>The <code>Show</code> type class is used for types that can be converted into <code>String</code>s. It looks (roughly) like this:</p>

<pre><code class="Haskell">class Show a where
    show :: a -&gt; String
</code></pre>

<p>There’s technically more to the definition of <code>Show</code>, but this is the part we care about.</p>

<h3><code>Read</code></h3>

<p><code>Read</code> is the opposite of <code>Show</code>. Where <code>Show</code> turns a value of some type into a <code>String</code>, <code>Read</code> turns a <code>String</code> into a value of some type. It looks (roughly) like this:</p>

<pre><code class="Haskell">class Read a where
    read :: String -&gt; a
</code></pre>

<p>One thing to note is that this function does something we haven’t seen before. The generic type is the return type! This means that we have to give the compiler a bit of help with a type annotation when we call <code>read</code>, so it knows what type we’re trying to get out, and can thus choose the correct implementation of <code>Read</code>. That looks like this:</p>

<pre><code class="Haskell">read &quot;1&quot; :: Int
</code></pre>

<p>Which says “call <code>read</code> with the parameter <code>&quot;1&quot;</code>, and convert the result into an <code>Int</code>”.</p>

<h3><code>Bounded</code></h3>

<p><code>Bounded</code> is used for types that have a maximum possible value and a minimum possible value. It looks like this:</p>

<pre><code class="Haskell">class Bounded a where
    minBound :: a
    maxBound :: a
</code></pre>

<p><code>minBound</code> and <code>maxBound</code> return the largest possible and smallest possible value of the implementing type, respectively.</p>

<h3><code>Enum</code></h3>

<p><code>Enum</code> is for types that can be <em>enumerated</em> (that is, listed in their entirety). It looks (roughly) like this:</p>

<pre><code class="Haskell">class Enum a where
    toEnum :: Int -&gt; a
    fromEnum :: a -&gt; Int
</code></pre>

<p>This definition may seem a bit strange, but it makes sense. <code>Int</code>s can be enumerated, and so the simplest way to define something that can be enumerated is to create some way to convert back and forth between that type and an <code>Int</code>. That’s what <code>toEnum</code> and <code>fromEnum</code> do.</p>

<h3><code>Integral</code></h3>

<p><code>Integral</code> is used for integer-like types, and looks (roughly) like this:</p>

<pre><code class="Haskell">class Enum a =&gt; Integral a where
    quot :: a -&gt; a -&gt; a
    rem :: a -&gt; a -&gt; a
    div :: a -&gt; a -&gt; a
    mod :: a -&gt; a -&gt; a
</code></pre>

<p><code>quot</code> performs integer division, returning the whole portion without remainder. <code>rem</code> performs integer division, returning the remainder only. <code>div</code> performs integer division truncated down. <code>mod</code> performs integer modulus.</p>

<h3><code>Num</code></h3>

<p><code>Num</code> is used for numbers, and looks (roughly) like this:</p>

<pre><code class="Haskell">class Num a where
    (+) :: a -&gt; a -&gt; a
    (-) :: a -&gt; a -&gt; a
    (*) :: a -&gt; a -&gt; a
    negate :: a -&gt; a
    abs :: a -&gt; a
    signum :: a -&gt; a
</code></pre>

<p>So <code>Num</code>s are types that can be added, subtracted, multiplied, negated, and from which you can get the absolute value and a number indicating the sign (either <code>-1</code>, <code>0</code>, or <code>1</code>).</p>

<h3><code>Fractional</code></h3>

<p><code>Fractional</code> is used for fraction-like types, and looks (roughly) like this:</p>

<pre><code class="Haskell">class Num a =&gt; Fractional a where
    (/) :: a -&gt; a -&gt; a
</code></pre>

<p>So <code>Fractional</code>s are <code>Num</code>s that also support real division.</p>

<h2>So Many Typeclasses!</h2>

<p>That’s a lot of typeclasses! Fortunately, they’re pretty easy to remember.</p>

<p><strong>Write some types of your own, and implement every type class listed above at least once. Save your work in a .hs file, make sure it compiles, and turn it in at the end of the lab.</strong></p>

<h2>A Convenient Shorthand</h2>

<p>Now, it would be a real pain to always have to manually implement these type classes. Fortunately, many typeclasses in Haskell can be automatically derived in the following way.</p>

<pre><code class="Haskell">data Blah Int = Blah Int deriving (Show)
</code></pre>

<p>The <code>deriving (Show)</code> part tells the Haskell compiler to attempt to automatically generate an implementation of <code>Show</code> for <code>Blah</code>.</p>

<p><strong>Write five types for which you collectively derive at least once all the typeclasses listed above which can be derived. Take note of which ones can’t be derived. Save your work in a .hs file for submission at the end of the lab. Make sure it compiles.</strong></p>

<h2>Conclusion</h2>

<p>Typeclasses are an excellent mechanism for writing generic code. By separating out your interfaces and combining them with the power of parametric polymorphism, you gain a simple, flexible, and powerful mechanism for writing generic code that works not only with the types you are aware of right now, but with future types which may be added to the code.</p>

<p><strong>That’s it for the lab. Make sure to submit what you have for grading!</strong></p>


